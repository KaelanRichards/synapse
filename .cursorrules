Synapse Project Specification
Overview
Synapse is a dynamic knowledge management platform designed to interconnect atomic knowledge units (notes) into meaningful clusters. It leverages a type-safe tech stack with Supabase, Next.js, React, TypeScript, Tailwind CSS, and React Flow to ensure scalability, maintainability, and an optimal developer experience.

Tech Stack
Frontend: Next.js 13, React, TypeScript, Tailwind CSS, React Query, React Flow
Backend: Supabase (PostgreSQL, Authentication, Realtime)
Deployment: Vercel, GitHub Actions for CI/CD
Data Models
TypeScript Interfaces
typescript
Copy code
// types/supabase.ts

export interface Note {
id: string;
title: string;
content: string;
connections: Connection[];
history: VersionHistory[];
context: string[];
createdAt: string;
updatedAt: string;
}

export interface Connection {
id: string;
type: 'related' | 'prerequisite' | 'refines';
strength: number;
bidirectional: boolean;
context: string;
emergent: boolean;
createdAt: string;
}

export interface VersionHistory {
versionId: string;
timestamp: string;
changes: string; // JSON diff or summary
}

export interface Database {
public: {
Tables: {
notes: {
Row: Note;
Insert: Partial<Note>;
Update: Partial<Note>;
};
connections: {
Row: Connection;
Insert: Partial<Connection>;
Update: Partial<Connection>;
};
note_versions: {
Row: NoteVersion;
Insert: Partial<NoteVersion>;
Update: Partial<NoteVersion>;
};
};
Views: {};
Functions: {};
};
}
Supabase Tables
sql
Copy code
-- Table: notes
CREATE TABLE notes (
id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
title TEXT NOT NULL,
content TEXT NOT NULL,
created_at TIMESTAMPTZ DEFAULT NOW(),
updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Table: connections
CREATE TABLE connections (
id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
note_from UUID REFERENCES notes(id) ON DELETE CASCADE,
note_to UUID REFERENCES notes(id) ON DELETE CASCADE,
connection_type TEXT CHECK (connection_type IN ('related', 'prerequisite', 'refines')),
strength FLOAT CHECK (strength >= 0 AND strength <= 10) DEFAULT 1.0,
bidirectional BOOLEAN DEFAULT FALSE,
context TEXT,
emergent BOOLEAN DEFAULT FALSE,
created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Table: note_versions
CREATE TABLE note_versions (
id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
note_id UUID REFERENCES notes(id) ON DELETE CASCADE,
version_number INT NOT NULL,
content TEXT NOT NULL,
created_at TIMESTAMPTZ DEFAULT NOW()
);
API Routes
Create a New Connection
typescript
Copy code
// pages/api/connections/index.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import supabase from '../../../lib/supabase';
import { Connection } from '../../../types/supabase';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
if (req.method === 'POST') {
const { note_from, note_to, connection_type, strength, bidirectional, context, emergent } = req.body;

    // Validate request data
    if (
      typeof note_from !== 'string' ||
      typeof note_to !== 'string' ||
      !['related', 'prerequisite', 'refines'].includes(connection_type) ||
      typeof strength !== 'number' ||
      typeof bidirectional !== 'boolean' ||
      typeof context !== 'string' ||
      typeof emergent !== 'boolean'
    ) {
      return res.status(400).json({ error: 'Invalid request data' });
    }

    // Insert connection
    const { data, error } = await supabase
      .from('connections')
      .insert([{ note_from, note_to, connection_type, strength, bidirectional, context, emergent }])
      .select()
      .single();

    if (error) return res.status(500).json({ error: error.message });

    // If bidirectional, create the reverse connection
    if (bidirectional) {
      const { error: reverseError } = await supabase
        .from('connections')
        .insert([{ note_from: note_to, note_to: note_from, connection_type, strength, bidirectional, context, emergent }])
        .select()
        .single();

      if (reverseError) return res.status(500).json({ error: reverseError.message });
    }

    return res.status(201).json(data);

}

res.setHeader('Allow', ['POST']);
res.status(405).end(`Method ${req.method} Not Allowed`);
}
Create a New Note
typescript
Copy code
// pages/api/notes/index.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import supabase from '../../../lib/supabase';
import { Note } from '../../../types/supabase';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
if (req.method === 'POST') {
const { title, content } = req.body;

    // Validate request data
    if (typeof title !== 'string' || typeof content !== 'string') {
      return res.status(400).json({ error: 'Invalid request data' });
    }

    // Insert note
    const { data, error } = await supabase
      .from('notes')
      .insert([{ title, content }])
      .select()
      .single();

    if (error) return res.status(500).json({ error: error.message });

    return res.status(201).json(data);

}

res.setHeader('Allow', ['POST']);
res.status(405).end(`Method ${req.method} Not Allowed`);
}
Frontend Components
NoteGraph Component
tsx
Copy code
// components/NoteGraph.tsx
import React from 'react';
import ReactFlow, { Elements, Background, Controls } from 'react-flow-renderer';
import { useNote } from '../hooks/useNote';

interface NoteGraphProps {
noteId: string;
}

const NoteGraph: React.FC<NoteGraphProps> = ({ noteId }) => {
const { data, error, isLoading } = useNote(noteId);

if (isLoading) return <div>Loading...</div>;
if (error) return <div>Error: {error.message}</div>;

const elements: Elements = [
{ id: data.id, data: { label: data.title }, position: { x: 250, y: 5 } },
...data.connections.map(conn => ({
id: conn.id,
source: conn.note_from,
target: conn.note_to,
label: conn.type,
animated: conn.emergent,
})),
];

return (
<div style={{ height: '500px', width: '100%' }}>
<ReactFlow elements={elements} style={{ width: '100%', height: '100%' }}>
<Background />
<Controls />
</ReactFlow>
</div>
);
};

export default NoteGraph;
Hooks
useNote Hook
typescript
Copy code
// hooks/useNote.ts
import { useQuery } from '@tanstack/react-query';
import supabase from '../lib/supabase';
import { Note, Connection } from '../types/supabase';

interface NoteWithConnections extends Note {
connections: Connection[];
}

const fetchNoteWithConnections = async (noteId: string): Promise<NoteWithConnections> => {
const { data: note, error: noteError } = await supabase
.from('notes')
.select('\*')
.eq('id', noteId)
.single();

if (noteError) throw new Error(noteError.message);

const { data: connections, error: connError } = await supabase
.from('connections')
.select('\*')
.eq('note_from', noteId);

if (connError) throw new Error(connError.message);

return { ...note, connections };
};

export const useNote = (noteId: string) => {
return useQuery<NoteWithConnections, Error>(
['note', noteId],
() => fetchNoteWithConnections(noteId),
{
enabled: !!noteId,
}
);
};
Authentication Flow
Sign-In Page
tsx
Copy code
// pages/signin.tsx
import { useState } from 'react';
import { useSupabase } from '../contexts/SupabaseContext';
import { useRouter } from 'next/router';

const SignIn: React.FC = () => {
const supabase = useSupabase();
const router = useRouter();
const [email, setEmail] = useState('');
const [password, setPassword] = useState('');

const handleSignIn = async (e: React.FormEvent) => {
e.preventDefault();
const { error } = await supabase.auth.signInWithPassword({ email, password });
if (error) {
alert(error.message);
} else {
router.push('/');
}
};

return (
<div className="flex items-center justify-center h-screen">
<form onSubmit={handleSignIn} className="border p-6 rounded">
<h2 className="text-xl mb-4">Sign In</h2>
<div className="mb-4">
<label className="block mb-1">Email</label>
<input
type="email"
className="border p-2 w-full"
value={email}
onChange={e => setEmail(e.target.value)}
required
/>
</div>
<div className="mb-4">
<label className="block mb-1">Password</label>
<input
type="password"
className="border p-2 w-full"
value={password}
onChange={e => setPassword(e.target.value)}
required
/>
</div>
<button type="submit" className="bg-blue-500 text-white p-2 rounded w-full">
Sign In
</button>
</form>
</div>
);
};

export default SignIn;
Protecting Routes with useAuth Hook
typescript
Copy code
// hooks/useAuth.ts
import { useEffect } from 'react';
import { useSession } from '@supabase/auth-helpers-react';
import { useRouter } from 'next/router';

export const useAuth = () => {
const { session } = useSession();
const router = useRouter();

useEffect(() => {
if (!session) {
router.push('/signin');
}
}, [session, router]);

return session;
};
Protected Note Detail Page
tsx
Copy code
// pages/notes/[id].tsx
import { useAuth } from '../../hooks/useAuth';
import NoteGraph from '../../components/NoteGraph';
import { NextPage } from 'next';
import { useRouter } from 'next/router';

const NoteDetail: NextPage = () => {
const session = useAuth();
const router = useRouter();
const { id } = router.query;

if (!session) {
return <div>Loading...</div>;
}

return (
<div className="p-4">
<NoteGraph noteId={id as string} />
{/_ Additional note details and editing options _/}
</div>
);
};

export default NoteDetail;
Context Providers
Supabase Context
typescript
Copy code
// contexts/SupabaseContext.tsx
import { createContext, useContext } from 'react';
import { createClient, SupabaseClient } from '@supabase/supabase-js';
import { Database } from '../types/supabase';

const SupabaseContext = createContext<SupabaseClient<Database> | null>(null);

export const SupabaseProvider: React.FC = ({ children }) => {
const supabase = createClient<Database>(
process.env.NEXT_PUBLIC_SUPABASE_URL!,
process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

return (
<SupabaseContext.Provider value={supabase}>
{children}
</SupabaseContext.Provider>
);
};

export const useSupabase = () => {
const context = useContext(SupabaseContext);
if (!context) {
throw new Error('useSupabase must be used within a SupabaseProvider');
}
return context;
};
Deployment & CI/CD
GitHub Actions Workflow
yaml
Copy code

# .github/workflows/ci-cd.yml

name: CI/CD Pipeline

on:
push:
branches: [ main ]
pull_request:
branches: [ main ]

jobs:
build:
runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install Dependencies
        run: npm install

      - name: Generate Types
        run: npm run generate:types

      - name: Lint
        run: npm run lint

      - name: Build
        run: npm run build

      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v20
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          working-directory: ./

Setup:
Add necessary secrets (VERCEL_TOKEN, VERCEL_ORG_ID, VERCEL_PROJECT_ID) to your GitHub repository settings.
Project Structure
lua
Copy code
synapse/
├── components/
│ ├── NoteGraph.tsx
│ └── ...other components
├── contexts/
│ └── SupabaseContext.tsx
├── hooks/
│ ├── useNote.ts
│ ├── useAuth.ts
│ └── ...other hooks
├── lib/
│ └── supabase.ts
├── pages/
│ ├── api/
│ │ ├── connections/
│ │ │ └── index.ts
│ │ ├── notes/
│ │ │ └── index.ts
│ │ └── ...other API routes
│ ├── notes/
│ │ └── [id].tsx
│ ├── signin.tsx
│ └── index.tsx
├── prisma/
│ └── schema.prisma
├── styles/
│ └── globals.css
├── types/
│ └── supabase.ts
├── .github/
│ └── workflows/
│ └── ci-cd.yml
├── .husky/
│ └── pre-commit
├── .eslintrc.js
├── tailwind.config.js
├── tsconfig.json
├── package.json
└── ...other configuration files
Key Steps for AI Assistant
Initialize the Project:

Set up the Next.js project with TypeScript and Tailwind CSS.
Configure Supabase with the provided tables and relationships.
Implement Authentication:

Set up Supabase Auth and integrate it with the frontend.
Develop Core Features:

Create components for notes, connections, and version history.
Implement AI-driven features using Next.js API routes.
Ensure Type Safety:

Generate and integrate TypeScript types from Supabase.
Utilize React Query for data fetching with type safety.
Set Up CI/CD:

Configure GitHub Actions for automated testing, type generation, and deployments.
Deploy the Application:

Deploy the frontend on Vercel and manage backend services via Supabase.
By following this concise project specification, the AI assistant can efficiently develop the Synapse platform, ensuring a robust and scalable knowledge management ecosystem with end-to-end type safety.
